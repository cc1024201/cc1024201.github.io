<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cc1024201.github.io</id>
    <title>zhcao.blog</title>
    <updated>2021-06-10T15:22:10.713Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cc1024201.github.io"/>
    <link rel="self" href="https://cc1024201.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://cc1024201.github.io/images/avatar.png</logo>
    <icon>https://cc1024201.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zhcao.blog</rights>
    <entry>
        <title type="html"><![CDATA[关于分析与构建可伸缩的高性能IO服务]]></title>
        <id>https://cc1024201.github.io/post/guan-yu-fen-xi-yu-gou-jian-ke-shen-suo-de-gao-xing-neng-io-fu-wu/</id>
        <link href="https://cc1024201.github.io/post/guan-yu-fen-xi-yu-gou-jian-ke-shen-suo-de-gao-xing-neng-io-fu-wu/">
        </link>
        <updated>2021-06-09T13:35:16.000Z</updated>
        <content type="html"><![CDATA[<p>《Scalable IO in Java》 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">原文连接</a><br>
《Scalable IO in Java》 是java.util.concurrent包的作者，大师Doug Lea关于分析与构建可伸缩的高性能IO服务的一篇经典文章，在文章中Doug Lea通过各个角度，循序渐进的梳理了服务开发中的相关问题，以及在解决问题的过程中服务模型的演变与进化，文章中基于Reactor反应器模式的几种服务模型架构，也被Netty、Mina等大多数高性能IO服务框架所采用，因此阅读这篇文章有助于你更深入了解Netty、Mina等服务框架的编程思想与设计模式。</p>
<h1 id="网络服务">网络服务</h1>
<p>在一般的网络或分布式服务等应用程序中，大都具备一些相同的处理流程</p>
<ol>
<li>读取请求数据；</li>
<li>对请求数据进行解码；</li>
<li>对数据进行处理；</li>
<li>对回复数据进行编码；</li>
<li>发送回复；<br>
当然在实际应用中每一步的运行效率都是不同的，例如其中可能涉及到xml解析、文件传输、web页面的加载、计算服务等不同功能。</li>
</ol>
<h2 id="传统的服务设计模式">传统的服务设计模式</h2>
<p>在一般的网络服务当中都会为每一个连接的处理开启一个新的线程，我们可以看下大致的示意图：<br>
<img src="https://cc1024201.github.io/post-images/1623246452594.png" alt="" loading="lazy"><br>
每一个连接的处理都会对应分配一个新的线程，下面我们看一段经典的Server端Socket服务代码：</p>
<pre><code class="language-java">class Server implements Runnable {
        public void run() {
            try {
                ServerSocket ss = new ServerSocket(PORT);
                while (!Thread.interrupted())
                    new Thread(new Handler(ss.accept())).start();
                // or, single-threaded, or a thread pool
            } catch (IOException ex) {
                /* ... */ 
            }
        }

        static class Handler implements Runnable {
            final Socket socket;

            Handler(Socket s) {
                socket = s;
            }

            public void run() {
                try {
                    byte[] input = new byte[MAX_INPUT];
                    socket.getInputStream().read(input);
                    byte[] output = process(input);
                    socket.getOutputStream().write(output);
                } catch (IOException ex) {
                    /* ... */ 
                }
            }

            private byte[] process(byte[] cmd) {
                /* ... */ 
            }
        }
    }
</code></pre>
<h2 id="构建高性能可伸缩的io服务">构建高性能可伸缩的IO服务</h2>
<p>在构建高性能可伸缩IO服务的过程中，我们希望达到以下的目标：</p>
<p>①　能够在海量负载连接情况下优雅降级；</p>
<p>②　能够随着硬件资源的增加，性能持续改进；</p>
<p>③　具备低延迟、高吞吐量、可调节的服务质量等特点；</p>
<p>而分发处理就是实现上述目标的一个最佳方式。</p>
<h2 id="分发模式">分发模式</h2>
<p>分发模式具有以下几个机制：</p>
<p>①　将一个完整处理过程分解为一个个细小的任务；</p>
<p>②　每个任务执行相关的动作且不产生阻塞；</p>
<p>③　在任务执行状态被触发时才会去执行，例如只在有数据时才会触发读操作；</p>
<p>在一般的服务开发当中，IO事件通常被当做任务执行状态的触发器使用，在hander处理过程中主要针对的也就是IO事件；<br>
<img src="https://cc1024201.github.io/post-images/1623246823006.png" alt="" loading="lazy"><br>
java.nio包就很好的实现了上述的机制：</p>
<p>①　非阻塞的读和写</p>
<p>②　通过感知IO事件分发任务的执行</p>
<p>所以结合一系列基于事件驱动模式的设计，给高性能IO服务的架构与设计带来丰富的可扩展性；</p>
<h1 id="基于事件驱动模式的设计">基于事件驱动模式的设计</h1>
<p>基于事件驱动的架构设计通常比其他架构模型更加有效，因为可以节省一定的性能资源，事件驱动模式下通常不需要为每一个客户端建立一个线程，这意味着更少的线程开销，更少的上下文切换和更少的锁互斥，但任务的调度可能会慢一些，而且通常实现的复杂度也会增加，相关功能必须分解成简单的非阻塞操作，类似与GUI的事件驱动机制，当然也不可能把所有阻塞都消除掉，特别是GC， page faults(内存缺页中断)等。由于是基于事件驱动的，所以需要跟踪服务的相关状态（因为你需要知道什么时候事件会发生）;</p>
<p>下图是AWT中事件驱动设计的一个简单示意图，可以看到，在不同的架构设计中的基于事件驱动的IO操作使用的基本思路是一致的；<br>
<img src="https://cc1024201.github.io/post-images/1623249595506.png" alt="" loading="lazy"></p>
<h1 id="reactor模式">Reactor模式</h1>
<p>Reactor也可以称作反应器模式，它有以下几个特点：</p>
<p>①　Reactor模式中会通过分配适当的handler(处理程序)来响应IO事件，类似与AWT 事件处理线程；</p>
<p>②　每个handler执行非阻塞的操作，类似于AWT ActionListeners 事件监听</p>
<p>③　通过将handler绑定到事件进行管理，类似与AWT addActionListener 添加事件监听；</p>
<h2 id="单线程模式">单线程模式</h2>
<p>下图展示的就是单线程下基本的Reactor设计模式<br>
<img src="https://cc1024201.github.io/post-images/1623249918722.png" alt="" loading="lazy"><br>
首先我们明确下java.nio中相关的几个概念：<br>
Channels<br>
支持非阻塞读写的socket连接；</p>
<p>Buffers<br>
用于被Channels读写的字节数组对象</p>
<p>Selectors<br>
用于判断channle发生IO事件的选择器</p>
<p>SelectionKeys<br>
负责IO事件的状态与绑定</p>
<p>Ok，接下来我们一步步看下基于Reactor模式的服务端设计代码示例：<br>
第一步  Rector线程的初始化</p>
<pre><code class="language-java">class Reactor implements Runnable { 
    final Selector selector;
    final ServerSocketChannel serverSocket;
    Reactor(int port) throws IOException {
        selector = Selector.open();
        serverSocket = ServerSocketChannel.open();
        serverSocket.socket().bind(new InetSocketAddress(port));
        serverSocket.configureBlocking(false);
        SelectionKey sk = serverSocket.register(selector, SelectionKey.OP_ACCEPT); //注册accept事件
        sk.attach(new Acceptor()); //调用Acceptor()为回调方法
    }
    
    public void run() { 
        try {
            while (!Thread.interrupted()) {//循环
                selector.select();
                Set selected = selector.selectedKeys();
                Iterator it = selected.iterator();
                while (it.hasNext())
                    dispatch((SelectionKey)(it.next()); //dispatch分发事件
                selected.clear();
            }
        } catch (IOException ex) { /* ... */ }
    }
    
    void dispatch(SelectionKey k) {
        Runnable r = (Runnable)(k.attachment()); //调用SelectionKey绑定的调用对象
        if (r != null)
            r.run();
    }
    
    // Acceptor 连接处理类
    class Acceptor implements Runnable { // inner
        public void run() {
            try {
                SocketChannel c = serverSocket.accept();
                if (c != null)
                new Handler(selector, c);
            }
            catch(IOException ex) { /* ... */ }
        }
    }
}
</code></pre>
<p>第二步 Handler处理类的初始化</p>
<pre><code class="language-java">final class Handler implements Runnable {
    final SocketChannel socket;
    final SelectionKey sk;
    ByteBuffer input = ByteBuffer.allocate(MAXIN);
    ByteBuffer output = ByteBuffer.allocate(MAXOUT);
    static final int READING = 0, SENDING = 1;
    int state = READING;
    
    Handler(Selector sel, SocketChannel c) throws IOException {
        socket = c;
        c.configureBlocking(false);
        // Optionally try first read now
        sk = socket.register(sel, 0);
        sk.attach(this); //将Handler绑定到SelectionKey上
        sk.interestOps(SelectionKey.OP_READ);
        sel.wakeup();
    }
    boolean inputIsComplete() { /* ... */ }
    boolean outputIsComplete() { /* ... */ }
    void process() { /* ... */ }
    
    public void run() {
        try {
            if (state == READING) read();
            else if (state == SENDING) send();
        } catch (IOException ex) { /* ... */ }
    }
    
    void read() throws IOException {
        socket.read(input);
        if (inputIsComplete()) {
            process();
            state = SENDING;
            // Normally also do first write now
            sk.interestOps(SelectionKey.OP_WRITE);
        }
    }
    void send() throws IOException {
        socket.write(output);
        if (outputIsComplete()) sk.cancel(); 
    }
}
</code></pre>
<p>下面是基于GoF状态对象模式对Handler类的一个优化实现，不需要再进行状态的判断。</p>
<pre><code class="language-java">class Handler { // ...
    public void run() { // initial state is reader
        socket.read(input);
        if (inputIsComplete()) {
            process();
            sk.attach(new Sender()); 
            sk.interest(SelectionKey.OP_WRITE);
            sk.selector().wakeup();
        }
    }
    class Sender implements Runnable {
        public void run(){ // ...
            socket.write(output);
            if (outputIsComplete()) sk.cancel();
        }
    }
}
</code></pre>
<h2 id="多线程设计模式">多线程设计模式</h2>
<p>在多处理器场景下，为实现服务的高性能我们可以有目的的采用多线程模式：</p>
<p>1、增加Worker线程，专门用于处理非IO操作，因为通过上面的程序我们可以看到，反应器线程需要迅速触发处理流程，而如果处理过程也就是process()方法产生阻塞会拖慢反应器线程的性能，所以我们需要把一些非IO操作交给Woker线程来做；</p>
<p>2、拆分并增加反应器Reactor线程，一方面在压力较大时可以饱和处理IO操作，提高处理能力；另一方面维持多个Reactor线程也可以做负载均衡使用；线程的数量可以根据程序本身是CPU密集型还是IO密集型操作来进行合理的分配；</p>
<h3 id="多线程模式">多线程模式</h3>
<p>Reactor多线程设计模式具备以下几个特点：</p>
<p>①　通过卸载非IO操作来提升Reactor 线程的处理性能，这类似与POSA2 中Proactor的设计；</p>
<p>②　比将非IO操作重新设计为事件驱动的方式更简单；</p>
<p>③　但是很难与IO重叠处理，最好能在第一时间将所有输入读入缓冲区；（这里我理解的是最好一次性读取缓冲区数据，方便异步非IO操作处理数据）</p>
<p>④　可以通过线程池的方式对线程进行调优与控制，一般情况下需要的线程数量比客户端数量少很多；<br>
下面是Reactor多线程设计模式的一个示意图与示例代码（我们可以看到在这种模式中在Reactor线程的基础上把非IO操作放在了Worker线程中执行）：<br>
<img src="https://cc1024201.github.io/post-images/1623250351763.png" alt="" loading="lazy"></p>
<pre><code class="language-java">class Handler implements Runnable {
        // uses util.concurrent thread pool
        static PooledExecutor pool = new PooledExecutor(...);//声明线程池
        static final int PROCESSING = 3;

        // ...
        synchronized void read() { // ...
            socket.read(input);
            if (inputIsComplete()) {
                state = PROCESSING;
                pool.execute(new Processer());//处理程序放在线程池中执行
            }
        }

        synchronized void processAndHandOff() {
            process();
            state = SENDING; // or rebind attachment
            sk.interest(SelectionKey.OP_WRITE);
        }

        class Processer implements Runnable {
            public void run() {
                processAndHandOff();
            }
        }
    }
</code></pre>
<p>当你把非IO操作放到线程池中运行时，你需要注意以下几点问题：</p>
<p>①　任务之间的协调与控制，每个任务的启动、执行、传递的速度是很快的，不容易协调与控制；</p>
<p>②　每个hander中dispatch的回调与状态控制；</p>
<p>③　不同线程之间缓冲区的线程安全问题；</p>
<p>④　需要任务返回结果时，任务线程等待和唤醒状态间的切换；</p>
<p>为解决上述问题可以使用PooledExecutor线程池框架，这是一个可控的任务线程池，主函数采用execute(Runnable r)，它具备以下功能，可以很好的对池中的线程与任务进行控制与管理：</p>
<p>①　可设置线程池中最大与最小线程数；</p>
<p>②　按需要判断线程的活动状态，及时处理空闲线程；</p>
<p>③　当执行任务数量超过线程池中线程数量时，有一系列的阻塞、限流的策略；</p>
<h3 id="基于多个反应器的多线程模式">基于多个反应器的多线程模式</h3>
<p>这是对上面模式的进一步完善，使用反应器线程池，一方面根据实际情况用于匹配调节CPU处理与IO读写的效率，提高系统资源的利用率，另一方面在静态或动态构造中每个反应器线程都包含对应的Selector,Thread,dispatchloop,下面是一个简单的代码示例与示意图（Netty就是基于这个模式设计的，一个处理Accpet连接的mainReactor线程，多个处理IO事件的subReactor线程）：</p>
<pre><code class="language-java">Selector[] selectors; // Selector集合，每一个Selector 对应一个subReactor线程
    //mainReactor线程
    class Acceptor { // ...
        public synchronized void run() { 
            //...
            Socket connection = serverSocket.accept(); 
            if (connection != null)
              new Handler(selectors[next], connection); 
            if (++next == selectors.length)
                next = 0;
        }
}
</code></pre>
<p><img src="https://cc1024201.github.io/post-images/1623250776042.png" alt="" loading="lazy"><br>
在服务的设计当中，我们还需要注意与java.nio包特性的结合：</p>
<p>一是注意线程安全，每个selectors 对应一个Reactor 线程，并将不同的处理程序绑定到不同的IO事件，在这里特别需要注意线程之间的同步；</p>
<p>二是java nio中文件传输的方式：</p>
<p>①　Memory-mapped files 内存映射文件的方式，通过缓存区访问文件；</p>
<p>②　Direct buffers直接缓冲区的方式，在合适的情况下可以使用零拷贝传输，但同时这会带来初始化与内存释放的问题（需要池化与主动释放）;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Netty]]></title>
        <id>https://cc1024201.github.io/post/netty/</id>
        <link href="https://cc1024201.github.io/post/netty/">
        </link>
        <updated>2021-06-09T13:11:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p><a href="https://netty.io/">Netty官网</a><br>
Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。<br>
Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景。</p>
<h1 id="应用场景">应用场景</h1>
<p>阿里分布式服务框架 Dubbo 的 Dubbo 协议默认使用 Netty 作为基础通信组件，而其中的RPC调用就是netty+反射。<br>
<img src="https://cc1024201.github.io/post-images/1623244755374.png" alt="" loading="lazy"><br>
经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信<br>
<img src="https://cc1024201.github.io/post-images/1623244804578.png" alt="" loading="lazy"></p>
<h1 id="netty-优势">Netty 优势</h1>
<h2 id="原生nio存在的问题">原生NIO存在的问题</h2>
<p>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。<br>
需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。<br>
开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。<br>
JDK NIO 的 Bug：例如Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</p>
<h2 id="netty的优点">Netty的优点</h2>
<p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。<br>
异步非阻塞通信<br>
Reactor模型优化<br>
高效的并发编程<br>
无锁化的串行设计理念<br>
基于内存池的缓冲区重用机制零拷贝<br>
提供对protobuf等高性能序列化协议支持<br>
设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.<br>
使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。<br>
高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。<br>
安全：完整的 SSL/TLS 和 StartTLS 支持。<br>
社区活跃、不断更新：发现的 Bug 可以被及时修复，同时，更多的新功能会被加入</p>
<h1 id="netty线程模型">Netty线程模型</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序]]></title>
        <id>https://cc1024201.github.io/post/pai-xu/</id>
        <link href="https://cc1024201.github.io/post/pai-xu/">
        </link>
        <updated>2021-06-08T13:48:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="描述">描述</h1>
<p>给定一个数组，编写一个函数，返回该数组排序后的形式。</p>
<h1 id="示例1">示例1</h1>
<blockquote>
<p>输入：[5,2,3,1,4]<br>
返回值：[1,2,3,4,5]</p>
</blockquote>
<h1 id="示例2">示例2</h1>
<blockquote>
<p>输入：[5,1,6,2,5]<br>
返回值：[1,2,5,5,6]</p>
</blockquote>
<p>排序算法可以分为内部排序和外部排序，内部排序是数据在内存中排序，外部排序是因为数据量很大，一次不能容纳所有记录，在排序过程中需要访问外存。<br>
常见的内部排序算法有：插入排序，希尔排序，选择排序，冒泡排序，归并排序，快速排序，堆排序，基数排序等。<br>
<img src="https://cc1024201.github.io/post-images/1623160428913.png" alt="" loading="lazy"><br>
<img src="https://cc1024201.github.io/post-images/1623160585803.png" alt="" loading="lazy"></p>
<ul>
<li>计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)（大O符号），坏的性能是O(n<sup>2</sup>)。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(n log n)。使用具有强大计算能力的计算机，能令时间复杂度趋近于O(n)（但不等于O(n)）。</li>
<li>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</li>
</ul>
<h2 id="冒泡排序">冒泡排序</h2>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>
冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要O(n<sub>2</sub>)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n<sub>2</sub>），而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。</p>
<p>冒泡排序算法的运作如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<ul>
<li>伪代码</li>
</ul>
<pre><code>function bubble_sort (array, length) {
    var i, j;
    for(i from 0 to length-1){
        for(j from 0 to length-1-i){
            if (array[j] &gt; array[j+1])
                swap(array[j], array[j+1])
        }
    }
}
函数 冒泡排序 输入 一个数组名称为array 其长度为length 
    i 从 0 到 (length - 1) 
        j 从 0 到 (length - 1 - i) 
            如果 array[j] &gt; array[j + 1] 
                交换 array[j] 和 array[j + 1] 的值 
            如果结束 
        j循环结束 
    i循环结束 
函数结束
</code></pre>
<pre><code class="language-java">private int[] bubbleSort(int[] array) {
    int temp;
    for (int i = 0; i &lt; array.length - 1; i++) {
        boolean Flag = false; // 是否发生交换。没有交换，提前跳出外层循环
        for (int j = 0; j &lt; array.length - 1 - i; j++) {
            if (array[j] &gt; array[j + 1]) {
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                Flag = true;
            }
        }
        if (!Flag)
        {
            break;
        }
    }
    return array;
}
</code></pre>
<h2 id="选择排序">选择排序</h2>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>
选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多(n-1)次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<pre><code class="language-java">public int[] MySort(int[] arr) {
        int temp;
        //总共经过N-1轮比较
        for (int i = 0; i &lt; arr.length - 1; i++) {
            int min = i;
            //每轮需要比较的次数N-i
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[min]) {
                    min = j; //记录当前能找到的最小值元素的下标
                }
            }
            //将找到的最小值和i位置的值进行交换
            if (min != i) {
                temp = arr[i];
                arr[i] = arr[min];
                arr[min] =  temp;

            }
        }
        return arr;
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>从第一个元素开始，该元素可以认为已经被排序<br>
取出下一个元素，在已经排序的元素序列中从后向前扫描<br>
如果该元素（已排序）大于新元素，将该元素移到下一位置<br>
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>
将新元素插入到该位置后<br>
重复步骤2~5</p>
<pre><code class="language-java">public int[] MySort(int[] arr) {
        int temp;
        //从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
        for (int i = 1; i &lt; arr.length; i++) {
            //记录要插入的数据
            temp = arr[i];
            //从已经排序的序列最右边开始比较，找到比其小的数
            int j = i;
            while (j &gt; 0 &amp;&amp; temp &lt; arr[j - 1]) {
                arr[j] = arr[j - 1];
                j--;
            }
            //存在比其小的数，插入
            if (j != i) {
                arr[j] = temp;
            }
        }
        return arr;
}
</code></pre>
<h2 id="希尔排序">希尔排序</h2>
<p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。<br>
希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++ ）。</p>
<p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<blockquote>
<p>13 14 94 33 82<br>
25 59 94 65 23<br>
45 27 73 25 39<br>
10</p>
</blockquote>
<p>然后我们对每列进行排序：</p>
<blockquote>
<p>10 14 73 25 23<br>
13 27 94 33 39<br>
25 59 94 65 82<br>
45</p>
</blockquote>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<blockquote>
<p>10 14 73<br>
25 23 13<br>
27 94 33<br>
39 25 59<br>
94 65 82<br>
45</p>
</blockquote>
<p>排序之后变为：</p>
<blockquote>
<p>10 14 13<br>
25 23 33<br>
27 25 59<br>
39 65 73<br>
45 94 82<br>
94</p>
</blockquote>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<h3 id="步长序列">步长序列</h3>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p>
<p>Donald Shell最初建议步长选择为n/2并且对步长取半直到步长达到1。虽然这样取可以比O(n<sup>2</sup>)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。</p>
<pre><code class="language-java">public int[] MySort(int[] arr) {
        int length = arr.length;
        int temp;
        for (int step = length / 2; step &gt;= 1; step /= 2) {
            for (int i = step; i &lt; length; i++) {
                temp = arr[i];
                int j = i - step;
                while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) {
                    arr[j + step] = arr[j];
                    j -= step;
                }
                arr[j + step] = temp;
            }
        }
        return arr;
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>是创建在归并操作上的一种有效的排序算法，效率为 O(n log n)<br>
采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p>采用分治法:</p>
<p>分割：递归地把当前序列平均分割成两半。<br>
集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</p>
<h3 id="归并操作">归并操作</h3>
<p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p>
<p>递归法（Top-down）</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p>迭代法（Bottom-up）<br>
原理如下（假设序列共有n个元素）：</p>
<ol>
<li>将序列每相邻两个数字进行归并操作，形成 ceil(n/2)个序列，排序后每个序列包含两/一个元素</li>
<li>若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1</li>
</ol>
<p>递归版：</p>
<pre><code class="language-java"></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反转链表]]></title>
        <id>https://cc1024201.github.io/post/fan-zhuan-lian-biao/</id>
        <link href="https://cc1024201.github.io/post/fan-zhuan-lian-biao/">
        </link>
        <updated>2021-06-08T13:13:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="描述">描述</h1>
<p>输入一个链表，反转链表后，输出链表的表头</p>
<h1 id="示例1">示例1</h1>
<blockquote>
<p>输入：{1，2，3}<br>
返回值：{3，2，1}</p>
</blockquote>
<h2 id="方法一构造链表">方法一：构造链表</h2>
<p>可以先用一个按照插入顺序排序的集合将单链表每个节点都存起来，然后再构造链表<br>
此方法简单易懂</p>
<pre><code class="language-java">/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Solution {
    public ListNode ReverseList(ListNode head) {
        if (null == head) {
            return null;
        }
        List&lt;ListNode&gt; list = new ArrayList&lt;&gt;();
        while (head != null) {
            list.add(head);
            head = head.next;
        }
        Collections.reverse(list);
        for (ListNode node : list) {
            node.next = null;
        }
        head = list.get(0);
        list.remove(0);
        ListNode currentNode = head;
        while (list.size() &gt; 0) {
            currentNode.next = list.get(0);
            list.remove(0);
            currentNode = currentNode.next;
        }
        return head;
    }
}
</code></pre>
<h2 id="方法二正规解法">方法二：正规解法</h2>
<p>此题想考察的的是：如何调整链表指针，来达到反转链表的目的。</p>
<ol>
<li>初始化：3个指针
<ul>
<li>pre指向已经反转好的链表的最后一个节点，最开始没有反转，所以为null</li>
<li>cur指向待反转链表的第一个节点，最开始第一个节点待反转，所以为head</li>
<li>nex指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表会失效，所以需要保存</li>
</ul>
</li>
<li>循环执行以下三个操作
<ul>
<li>nex = cur.next, 保存作用</li>
<li>cur.next = pre，没有反转的链表的第一个节点的下个节点是已反转链表的最后一个节点（在此完成反转）</li>
<li>pre = cur, cur = nex; 指针后移， 操作下一个未反转链表的第一个节点</li>
</ul>
</li>
</ol>
<pre><code class="language-java">/*
public class ListNode {
  int val;
  ListNode next = null;

  ListNode(int val) {
      this.val = val;
  }
}*/
public class Solution {
  public ListNode ReverseList(ListNode head) {
      ListNode pre = null;
      ListNode cur = head;
      ListNode nex = null;
      while (null != cur) {
          nex = cur.next; //记录当前节点的下一个节点位置
          cur.next = pre; //让当前节点指向前一个节点位置，完成反转
          pre = cur; //pre往右走
          cur = nex; //当前节点往右走
      }
      return pre;
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云 Spring Boot 脚手架]]></title>
        <id>https://cc1024201.github.io/post/a-li-yun-spring-boot-jiao-shou-jia/</id>
        <link href="https://cc1024201.github.io/post/a-li-yun-spring-boot-jiao-shou-jia/">
        </link>
        <updated>2021-05-26T15:23:31.000Z</updated>
        <content type="html"><![CDATA[<p>https://start.aliyun.com/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://cc1024201.github.io/post/about/</id>
        <link href="https://cc1024201.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<h2 id="联系我呀">📬 联系我呀</h2>
]]></content>
    </entry>
</feed>