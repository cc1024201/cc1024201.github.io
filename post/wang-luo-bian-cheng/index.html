<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>网络编程 | zhcao.blog</title>
<link rel="shortcut icon" href="https://cc1024201.github.io/favicon.ico?v=1623593664092">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cc1024201.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="网络编程 | zhcao.blog - Atom Feed" href="https://cc1024201.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="如果我问你一些关于网络编程方面的问题，你会怎样回答呢？

大家经常说的四层、七层，分别指的是什么？
TCP 三次握手是什么，TIME_WAIT 是怎么发生的？CLOSE_WAIT 又是什么状态？
Linux 下的 epoll 解决的是什么问..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://cc1024201.github.io">
  <img class="avatar" src="https://cc1024201.github.io/images/avatar.png?v=1623593664092" alt="">
  </a>
  <h1 class="site-title">
    zhcao.blog
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              网络编程
            </h2>
            <div class="post-info">
              <span>
                2021-06-13
              </span>
              <span>
                5 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>如果我问你一些关于网络编程方面的问题，你会怎样回答呢？</p>
<blockquote>
<p>大家经常说的四层、七层，分别指的是什么？<br>
TCP 三次握手是什么，TIME_WAIT 是怎么发生的？CLOSE_WAIT 又是什么状态？<br>
Linux 下的 epoll 解决的是什么问题？如何使用 epoll 写出高性能的网络程序？<br>
什么是网络事件驱动模型？Reactor 模式又是什么？</p>
</blockquote>
<p>很多情况下，我们都希望尽可能详尽地学习网络编程，面面俱到，但奈何头绪太多。<br>
比如流量控制和拥塞控制只是网络编程一小部分的内容，进程、线程、多路复用、异步 I/O 这些概念一摆出来，又会让人一头雾水。</p>
<p>很多人在理论部分折了戟，干脆跑向了另一个极端，转而去学习框架，快速上手。事实上，理论是基石，框架则是站在一个更为抽象的角度来看待网络编程问题。框架的产生或是为了实现跨平台支持，例如 JDK。没有理论为底，框架也只是空中楼阁。直接学习框架反而会更加摸不着头脑，对网络编程也很难有实打实的收获。</p>
<p>事实上，学习高性能网络编程，掌握两个核心要点就可以了：第一就是理解网络协议，并在这个基础上和操作系统内核配合，感知各种网络 I/O 事件；第二就是学会使用线程处理并发。</p>
<p>要学好网络编程，需要达到以下三个层次。<br>
第一个层次，充分理解 TCP/IP 网络模型和协议。（套接字，套接字缓冲区，拥塞控制，数据包和数据流，本地套接字（UNIX 域套接字）等）<br>
第二个层次，结合对协议的理解，增强对各种异常情况的优雅处理能力。（TCP 数据流的处理，半关闭的连接，TCP 连接有效性的侦测，处理各种异常情况等，这些问题决定了程序的健壮性。）<br>
第三个层次，写出可以支持大规模高并发的网络处理程序。（深入研究 C10K 问题，引入进程、线程、多路复用、非阻塞、异步、事件驱动等现代高性能网络编程所需要的技术。）</p>
<h1 id="tcpip">TCP/IP</h1>
<h2 id="osi-tcpip">OSI &amp; TCP/IP</h2>
<p><img src="https://cc1024201.github.io/post-images/1623587113767.jpg" alt="" loading="lazy"><br>
<img src="https://cc1024201.github.io/post-images/1623587120954.jpg" alt="" loading="lazy"></p>
<h1 id="网络编程模型">网络编程模型</h1>
<h2 id="客户端-服务器网络编程模型">客户端-服务器网络编程模型</h2>
<figure data-type="image" tabindex="1"><img src="https://cc1024201.github.io/post-images/1623591951370.PNG" alt="" loading="lazy"></figure>
<ol>
<li>当一个客户端需要服务时，比如网络购物下单，它会向服务器端发送一个请求。注意，<br>
这个请求是按照双方约定的格式来发送的，以便保证服务器端是可以理解的；</li>
<li>服务器端收到这个请求后，会根据双方约定的格式解释它，并且以合适的方式进行操<br>
作，比如调用数据库操作来创建一个购物单；</li>
<li>服务器端完成处理请求之后，会给客户端发送一个响应，比如向客户端发送购物单的实<br>
际付款额，然后等待客户端的下一步操作；</li>
<li>客户端收到响应并进行处理，比如在手机终端上显示该购物单的实际付款额，并且让用<br>
户选择付款方式。</li>
</ol>
<p>服务器端需要在一开始就监听在一个众所周知的端口上，等待客户端发送请求，一旦有客户端连接建立，服器端就会消耗一定的计算机资源为它服务，服务器端是需要同时为成千上万的客户端服务的。<br>
客户端相对来说更为简单，它向服务器端的监听端口发起连接请求，连接建立之后，通过连接通路和服务器端进行通信。<br>
还有一点需要强调的是，无论是客户端，还是服务器端，它们运行的单位都是进程（process），而不是机器。</p>
<h2 id="ip-和端口">IP 和端口</h2>
<p>一个连接可以通过客户端 - 服务器端的 IP 和端口唯一确定，这叫做套接字对，按照下面的<br>
四元组表示：（clientaddr:clientport, serveraddr: serverport)<br>
客户端 - 服务器之间的连接：<br>
<img src="https://cc1024201.github.io/post-images/1623592818501.PNG" alt="" loading="lazy"></p>
<h3 id="保留网段">保留网段</h3>
<p>国际标准组织在 IPv4 地址空间里面，专门划出了一些网段，这些网段不会用做公网上的 IP，而是仅仅保留做内部使用，我们把这些地址称作保留网段。<br>
三个保留网段，其可以容纳的计算机主机个数分别是 16777216 个、1048576 个和65536 个。<br>
<img src="https://cc1024201.github.io/post-images/1623592968338.PNG" alt="" loading="lazy"></p>
<h3 id="子网掩码">子网掩码</h3>
<h2 id="全球域名系统">全球域名系统</h2>
<figure data-type="image" tabindex="2"><img src="https://cc1024201.github.io/post-images/1623593169441.PNG" alt="" loading="lazy"></figure>
<h2 id="数据报和字节流">数据报和字节流</h2>
<p>TCP，又被叫做字节流套接字（Stream Socket）<br>
UDP 也有一个类似的叫法, 数据报套接字（Datagram Socket）<br>
一般分别以“SOCK_STREAM”与“SOCK_DGRAM”分别来表示 TCP 和 UDP 套接字。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#tcpip">TCP/IP</a>
<ul>
<li><a href="#osi-tcpip">OSI &amp; TCP/IP</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">网络编程模型</a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">客户端-服务器网络编程模型</a></li>
<li><a href="#ip-%E5%92%8C%E7%AB%AF%E5%8F%A3">IP 和端口</a>
<ul>
<li><a href="#%E4%BF%9D%E7%95%99%E7%BD%91%E6%AE%B5">保留网段</a></li>
<li><a href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81">子网掩码</a></li>
</ul>
</li>
<li><a href="#%E5%85%A8%E7%90%83%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">全球域名系统</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81">数据报和字节流</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://cc1024201.github.io/post/guan-yu-fen-xi-yu-gou-jian-ke-shen-suo-de-gao-xing-neng-io-fu-wu/">
              <h3 class="post-title">
                关于分析与构建可伸缩的高性能IO服务
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by &nbsp; <a href="https://github.com/cc1024201" target="_blank">zhcao</a>
  <a class="rss" href="https://cc1024201.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
